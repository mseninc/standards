#  コーディング規約

## 目次
<!-- TOC -->

- [型、クラス関係](#%E5%9E%8B%E3%82%AF%E3%83%A9%E3%82%B9%E9%96%A2%E4%BF%82)
    - [目次](#%E7%9B%AE%E6%AC%A1)
    - [型](#%E5%9E%8B)
        - [プリミティブ型](#%E3%83%97%E3%83%AA%E3%83%9F%E3%83%86%E3%82%A3%E3%83%96%E5%9E%8B)
        - [参照型](#%E5%8F%82%E7%85%A7%E5%9E%8B)
    - [参照](#%E5%8F%82%E7%85%A7)
    - [オブジェクト](#%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88)
    - [配列](#%E9%85%8D%E5%88%97)
    - [分割代入](#%E5%88%86%E5%89%B2%E4%BB%A3%E5%85%A5)
    - [文字列](#%E6%96%87%E5%AD%97%E5%88%97)
    - [関数](#%E9%96%A2%E6%95%B0)
    - [アロー関数](#%E3%82%A2%E3%83%AD%E3%83%BC%E9%96%A2%E6%95%B0)
    - [クラスとコンストラクター](#%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%A8%E3%82%B3%E3%83%B3%E3%82%B9%E3%83%88%E3%83%A9%E3%82%AF%E3%82%BF%E3%83%BC)
    - [プロパティ](#%E3%83%97%E3%83%AD%E3%83%91%E3%83%86%E3%82%A3)
    - [変数](#%E5%A4%89%E6%95%B0)

<!-- /TOC -->
## 型

* プリミティブ型は値を直接操作して下さい。
また、参照型は参照を通して値を操作して下さい。

### プリミティブ型

* `string`
* `number`
* `boolean`
* `null`
* `undefined`

### 参照型

* `object`
* `array`
* `function`

## 参照

* すべての参照は`const`を使用し、`var`を使用しないで下さい。
参照を再割り当てできないことで、バグに繋がりやすく理解しがたいコードになることを防ぎます。また、参照を再割当てする場合は`var`の代わりに`let`を使用して下さい。`let`は`var`のように関数スコープではなくブロックスコープです。
`let`と`const`はブロックスコープであることに注意して下さい。

## オブジェクト

* オブジェクトを作成する際は、`const item = new Object();`とせず、`const item = {};`という風にリテラル構文を使用して下さい。
* 動的にプロパティ名を持つオブジェクトを作成する場合、
```js
const obj = {
  id: 5,
  name: 'San Francisco',
};
obj[getKey('enabled')] = true;
```
とせず、
```js
const obj = {
  id: 5,
  name: 'San Francisco',
  [getKey('enabled')]: true,
};
```
として下さい。
* メソッドやプロパティの記述は短縮構文を使用して下さい。
* プロパティの短縮構文はオブジェクト宣言の先頭にまとめて下さい。
どのプロパティが短縮構文を利用しているか分かりやすいからです。
*  無効な識別子の場合のみプロパティを引用符で括ること。
一般的にこちらの方が読みやすいと考えてられています。これは構文の強調表示を改善し、また多くのJSエンジンによってより簡単に最適化されます。
* `hasOwnProperty`、`propertyIsEnumerable`、`isPrototypeOf`のような`Object.prototype`の関数を直接呼び出さないで下さい。これらのメソッドはオブジェクトのプロパティによって隠されている可能性があるかもしれません - `{ hasOwnProperty：false }`のようなケースを考えてください - あるいは、オブジェクトはnullオブジェクト( `Object.create(null)` )になっているかもしれません。
* オブジェクトをシャローコピーする場合は`Object.assign`よりもオブジェクトスプレッド構文を使用すること。特定のプロパティを省略した新しいオブジェクトを取得するには、オブジェクトのレスト演算子を使用すること。
以下に例を記します。
```js
// very bad
const original = { a: 1, b: 2 };
const copy = Object.assign(original, { c: 3 }); // this mutates `original` ಠ_ಠ
delete copy.a; // so does this

// bad
const original = { a: 1, b: 2 };
const copy = Object.assign({}, original, { c: 3 }); // copy => { a: 1, b: 2, c: 3 }

// good
const original = { a: 1, b: 2 };
const copy = { ...original, c: 3 }; // copy => { a: 1, b: 2, c: 3 }

const { a, ...noA } = copy; // noA => { b: 2, c: 3 }
```

## 配列

* 配列を作成する際は、オブジェクトの作成と同じようにリテラル構文を使用して下さい。
* 直接配列に項目を代入せず、Array#pushを使用して下さい。
* 配列をコピーする場合は、`const itemsCopy = [...items];`という風に配列の拡張演算子`...`を使用して下さい。
* 繰り返し可能なオブジェクトを配列に変換する場合は、
```js
const foo = document.querySelectorAll('.foo');

// good
const nodes = Array.from(foo);

// best
const nodes = [...foo];
```
という風に`Array.from`の代わりにスプレッド構文`...`を使用して下さい。
* array-likeオブジェクトを配列に変換する場合は、
`const arr = Array.prototype.slice.call(arrLike);`とするのではなく、
`const arr = Array.from(arrLike);`という風に`Array.from`を使用すること。
* 繰り返し可能なオブジェクト(iterables)へのマッピングにはスプレッド構文`...`の代わりに`Array.from`を使用すること。理由は中間配列の作成を防ぐためです。
* 配列のコールバック関数の中ではreturn構文を使用すること。もし関数の中が副作用のない式を返す一行で構成されている場合はreturnを省略してもかまいません。
* 配列が複数行ある場合、配列の開始の括弧の後と、最後の括弧の前に改行を入れること。

## 分割代入

* 複数のプロパティからなるオブジェクトにアクセスする際は、オブジェクト構造化代入を使用すること。構造化代入を利用することで、それらのプロパティのための中間的な参照を減らすことができます。具体的には、
```js
function getFullName(user) {
  const firstName = user.firstName;
  const lastName = user.lastName;

  return `${firstName} ${lastName}`;
}
```
とするのではなく、
```js
function getFullName({ firstName, lastName }) {
  return `${firstName} ${lastName}`;
}
```
という風にして下さい。
* 配列の構造化代入を使用して下さい。
* 複数の値を返却する場合は、配列の構造化代入ではなく、オブジェクトの構造化代入を使用すること。こうすることで、後で新しいプロパティを追加したり、呼び出し元に影響することなく順序を変更することができます。

## 文字列

* 文字列にはシングルクオート `''` を使用して下さい。
* 100文字以上になるような文字列は、文字列連結を使用して複数行にまたがって記述しない。
作業するうえで負担になる上にコードの検索容易性を損ないます。
* プログラムで文字列を生成する場合は、文字列連結ではなく、Template stringsを使用すること。Template strings は文字列補完機能・複数行文字列機能を持つ簡潔な構文で、可読性が良いからです。
* 絶対に eval() を利用しない。これは、いままで数多くの脆弱性を作って来たからです。
* 文字列の中で文字を不必要にエスケープしない。バックスラッシュは可読性を損なうため、必要なときにだけ存在させるべきです。

## 関数

* 関数宣言ではなく名前付き関数式を使用すること。関数の定義は巻き上げられます。このことはそれがファイルの中で定義されている場所よりも前に参照されることを意味します。それは読みやすさや保守性を損ないます。
関数の定義が十分に大きいか複雑であることがわかった場合、モジュールに展開するようにして下さい。
名前が定義されている変数から推測されるかどうかにかかわらず、式に明示的に名前を付けることを忘れないでください(モダンブラウザやBabelなどのコンパイラを使用している場合によくあります)。これにより、エラーの呼び出しスタックに関して行われた前提がなくなります。
* 即時呼び出し関数式(IIFE)を括弧で囲むこと。即時関数式は単一の単位であり、その両方とその呼び出し括弧を括弧で囲んで明確に表します。モジュールがある場合は必要ありません。
* 関数ではないブロック(`if`, `while`, など)の中で関数を定義しない。代わりに変数に関数を割り当てること。ブラウザは実行を許可しますが、すべて違ったように解釈されます。
* パラメータに`arguments`を指定しないで下さい。関数スコープに渡される`arguments`オブジェクトの参照を上書きしてしまいます。
* `arguments`を利用しない。代わりにrest syntax`...`を使用すること。`...`を利用することで、いつくかのパラメータを利用したいことを明らかにすることができます。加えてrestパラメータは`arguments`の様なArray-likeなオブジェクトではなく正真正銘のArrayです。
* 関数のパラメータを突然変異させるのではなく、デフォルトパラメータを使用すること。
```js
// really bad
function handleThings(opts) {
  // No! We shouldn't mutate function arguments.
  // Double bad: if opts is falsy it'll be set to an object which may
  // be what you want but it can introduce subtle bugs.

  // だめ！関数のパラメータを突然変異させるべきではありません。
  // もし、optsがfalsyだった場合は、望んだようにオブジェクトが設定されます。
  // しかし、微妙なバグを引き起こすかもしれません。
  opts = opts || {};
  // ...
}

// still bad
function handleThings(opts) {
  if (opts === void 0) {
    opts = {};
  }
  // ...
}

// good
function handleThings(opts = {}) {
  // ...
}
```
* 副作用のあるデフォルトパラメータの利用を避ける。
* `function handleThings(name, opts = {})`という風に常にデフォルトパラメータは末尾に配置すること。
* 新しい関数を作成するためにFunctionコンストラクタを使用しない。この方法で文字列を評価させて新しい関数を作成することは、eval()と同様の脆弱性を引き起こします。
```js
// bad
var add = new Function('a', 'b', 'return a + b');

// still bad
var subtract = Function('a', 'b', 'return a - b');
```
* 関数構文の中にスペースを入れること。
```js
// bad
const f = function(){};
const g = function (){};
const h = function() {};

// good
const x = function () {};
const y = function a() {};
```
* パラメータを直接操作しないこと。パラメータに渡されたオブジェクトを操作することは、呼び出し元にて望まれない値の副作用を及ぼす可能性があります。
```js
// bad
function f1(obj) {
  obj.key = 1;
}

// good
function f2(obj) {
  const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1;
}
```
* パラメータを再割り当てしない。特に`arguments`オブジェクトにアクセスするとき、パラメータを再割り当てすると予期しない動作をする可能性があります。 特にV8では最適化の問題も発生する可能性があります。
```js
// bad
function f1(a) {
  a = 1;
  // ...
}

function f2(a) {
  if (!a) { a = 1; }
  // ...
}

// good
function f3(a) {
  const b = a || 1;
  // ...
}

function f4(a = 1) {
  // ...
}
```
* 可変引数の関数を呼び出す場合はスプレッド演算子`...`を使用すること。
* 複数行の関数構文や呼び出しではインデントして下さい。最後の項目に末尾のコンマを付けて、行の各項目を単独で指定すること。

## アロー関数

* 無名関数を使用する必要がある場合は、アロー関数表記を使用してください。アロー関数はそのコンテキストの`this`で実行するバージョンの関数を作成します。これは通常期待通りの動作をし、より簡潔な構文だからです。
複雑な関数でロジックを定義した関数の外側に移動したい場合は使用しないで下さい。
* 関数本体が副作用のない式を返す単一の文で構成されている場合は、中括弧を省略して暗黙の戻り値を使用すること。そうでなければ、中括弧を付けて`return`文を使うこと。複数の関数が連結されている場合に読み易くなります。
* 式の全長が複数行にまたがる場合は、可読性をより良くするため丸括弧()で囲うこと。関数の開始と終了部分が分かりやすく見るためです。
* 関数が単一の引数を取り、中括弧を使用しない場合は、括弧を省略すること。 それ以外の場合は、明確さと一貫性を保つために、引数を常に括弧で囲むこと。常に括弧を使用する場合は、eslintに“always”オプションを使用すること。
* アロー関数の構文(`=>`)と比較演算子(`<=`、`>=`)を混同しない。
* 暗黙的な戻り値でアロー関数本体の位置を強制すること。

## クラスとコンストラクター

* `prototype`を直接操作することを避け、常に`class`を使用すること。
* 継承には`extends`を使用すること。
* メソッドの戻り値で`this`を返すことでメソッドチェーンを助けること。
```js
// bad
Jedi.prototype.jump = function () {
  this.jumping = true;
  return true;
};

Jedi.prototype.setHeight = function (height) {
  this.height = height;
};

const luke = new Jedi();
luke.jump(); // => true
luke.setHeight(20); // => undefined

// good
class Jedi {
  jump() {
    this.jumping = true;
    return this;
  }

  setHeight(height) {
    this.height = height;
    return this;
  }
}

const luke = new Jedi();

luke.jump()
  .setHeight(20);
```
* 独自の`toString()`の作成は認めますが、正しく動作することと副作用がないことを確認すること。
* 一つも指定されていない場合、クラスにはデフォルトのコンストラクタがあります。空のコンストラクタ関数やただ親クラスに移譲するだけのものは不要です。
* クラスのメンバの重複を避ける。重複したクラスメンバの宣言は暗黙的に最後のものが適用されます。重複を持つことはほぼ確実にバグです。

## プロパティ

* プロパティにアクセスする場合はドット(`.`)を使用すること。
* 変数を使用してプロパティにアクセスする場合は角括弧(`[]`)を使用すること
* べき乗を計算するときは、べき乗演算子`**`を使用すること。

## 変数

* 変数を宣言する際は、常に`const`か`let`を使用すること。使用しない場合はグローバル変数として宣言されてしまいます。グローバルな名前空間を汚染しないようにしましょう。
* 1つの変数宣言に対して1つの`const`を利用すること。この方法の場合、簡単に新しい変数を追加することができます。また、二度と区切り文字の違いによる`;`を`,`に置き換える作業を心配することがありません。すべての宣言を一度にジャンプするのではなく、デバッガーを使用して各宣言をステップスルーすることもできます。
* まず`const`をグループ化し、その後`let`をグループ化すること。以前に割り当てられた変数に後で変数を割り当てる必要がある場合に役立ちます。
* 変数を割り当てる際は、必要かつ合理的な場所で行うこと。`let`と`const`はブロックスコープだからです。関数スコープではありません。
* 変数代入を連結しない。変数代入を連鎖させると、暗黙のグローバル変数が作成されます。
* インクリメント演算子(`++`)デクリメント演算子(`--`)を使わない。インクリメントおよびデクリメント演算子は自動セミコロン挿入の対象となり、アプリケーション内で値の増加または減少を伴う予期せぬエラーを引き起こす可能性があります。`num++`や`num++`の代わりに`num += 1`のような構文で値を変更する方が表現力豊かです。インクリメントおよびデクリメント演算子を許可しないことで、直前の意図しない値の増加または減少による、プログラムでの予期しない動作を引き起こす可能性を防ぐことができます。
* 代入で`=`の前後に改行を入れない。あなたの代入が`max-len`に違反している場合は、値を丸括弧()で囲むこと。
* 未使用の変数を記述しない。宣言されていてコードのどこにも使用されていない変数は、不完全なリファクタリングによる失敗である可能性が最も高いです。このような変数はコード内のスペースを占有し、他の開発者にとって混乱を招く可能性があります。