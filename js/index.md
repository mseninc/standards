## このドキュメントについて

### 本文の目的

命名規則、コーディング規則を遵守して生産性を上げることを目的としています。

自分で書いたコードでも長い間メンテナンスしなければ他人のコードと同じです。
読みやすく、バグの少ない、メンテナンスのしやすいコードを目指しましょう。
規約に従うことは、多くの問題を改善し、技術的負債を減らします。

[Airbnb JavaScript スタイルガイド](https://mitsuruog.github.io/javascript-style-guide/) を参考にしています。

## 開発環境

ガイドはBabelを使っていることを前提としており、babel-preset-airbnbかそれと同等のものを使うことが必須です。また、airbnb-browser-shimsまたはそれと同等のシム/ポリフィルをアプリにインストールする必要があります。

## 目次
<!-- TOC -->

- [このドキュメントについて](#%E3%81%93%E3%81%AE%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6)
    - [本文の目的](#%E6%9C%AC%E6%96%87%E3%81%AE%E7%9B%AE%E7%9A%84)
- [開発環境](#%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83)
- [目次](#%E7%9B%AE%E6%AC%A1)
- [型](#%E5%9E%8B)
    - [プリミティブ型](#%E3%83%97%E3%83%AA%E3%83%9F%E3%83%86%E3%82%A3%E3%83%96%E5%9E%8B)
    - [参照型](#%E5%8F%82%E7%85%A7%E5%9E%8B)
- [参照](#%E5%8F%82%E7%85%A7)
- [オブジェクト](#%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88)
- [配列](#%E9%85%8D%E5%88%97)
- [分割代入](#%E5%88%86%E5%89%B2%E4%BB%A3%E5%85%A5)
- [文字列](#%E6%96%87%E5%AD%97%E5%88%97)
- [関数](#%E9%96%A2%E6%95%B0)
- [アロー関数](#%E3%82%A2%E3%83%AD%E3%83%BC%E9%96%A2%E6%95%B0)
- [クラスとコンストラクター](#%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%A8%E3%82%B3%E3%83%B3%E3%82%B9%E3%83%88%E3%83%A9%E3%82%AF%E3%82%BF%E3%83%BC)
- [モジュール](#%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB)
- [イテレータとジェネレータ](#%E3%82%A4%E3%83%86%E3%83%AC%E3%83%BC%E3%82%BF%E3%81%A8%E3%82%B8%E3%82%A7%E3%83%8D%E3%83%AC%E3%83%BC%E3%82%BF)
- [プロパティ](#%E3%83%97%E3%83%AD%E3%83%91%E3%83%86%E3%82%A3)
- [変数](#%E5%A4%89%E6%95%B0)
- [巻き上げ](#%E5%B7%BB%E3%81%8D%E4%B8%8A%E3%81%92)
- [比較演算子と同等性](#%E6%AF%94%E8%BC%83%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%A8%E5%90%8C%E7%AD%89%E6%80%A7)
- [ブロック](#%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF)
- [制御ステートメント](#%E5%88%B6%E5%BE%A1%E3%82%B9%E3%83%86%E3%83%BC%E3%83%88%E3%83%A1%E3%83%B3%E3%83%88)
- [コメント](#%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88)
- [空白](#%E7%A9%BA%E7%99%BD)
- [カンマ](#%E3%82%AB%E3%83%B3%E3%83%9E)
- [セミコロン](#%E3%82%BB%E3%83%9F%E3%82%B3%E3%83%AD%E3%83%B3)
- [型キャストと強制](#%E5%9E%8B%E3%82%AD%E3%83%A3%E3%82%B9%E3%83%88%E3%81%A8%E5%BC%B7%E5%88%B6)
- [命名規則](#%E5%91%BD%E5%90%8D%E8%A6%8F%E5%89%87)
- [アクセサ](#%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B5)
- [イベント](#%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88)
- [jQuery](#jquery)
- [標準ライブラリ](#%E6%A8%99%E6%BA%96%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA)
- [テスト](#%E3%83%86%E3%82%B9%E3%83%88)

<!-- /TOC -->

## 型

* プリミティブ型は値を直接操作して下さい。
また、参照型は参照を通して値を操作して下さい。

### プリミティブ型

* `string`
* `number`
* `boolean`
* `null`
* `undefined`

### 参照型

* `object`
* `array`
* `function`

## 参照

* すべての参照は`const`を使用し、`var`を使用しないで下さい。
参照を再割り当てできないことで、バグに繋がりやすく理解しがたいコードになることを防ぎます。
また、参照を再割当てする場合は`var`の代わりに`let`を使用して下さい。`let`は`var`のように関数スコープではなくブロックスコープです。
`let`と`const`はブロックスコープであることに注意して下さい。

## オブジェクト

* オブジェクトを作成する際は、`const item = new Object();`とせず、`const item = {};`という風にリテラル構文を使用して下さい。
* 動的にプロパティ名を持つオブジェクトを作成する場合、
```js
const obj = {
  id: 5,
  name: 'San Francisco',
};
obj[getKey('enabled')] = true;
```
とせず、
```js
const obj = {
  id: 5,
  name: 'San Francisco',
  [getKey('enabled')]: true,
};
```
として下さい。
* メソッドやプロパティの記述は短縮構文を使用して下さい。
* プロパティの短縮構文はオブジェクト宣言の先頭にまとめて下さい。
どのプロパティが短縮構文を利用しているか分かりやすいからです。
*  無効な識別子の場合のみプロパティを引用符で括ること。
一般的にこちらの方が読みやすいと考えてられています。これは構文の強調表示を改善し、また多くのJSエンジンによってより簡単に最適化されます。
* `hasOwnProperty`、`propertyIsEnumerable`、`isPrototypeOf`のような`Object.prototype`の関数を直接呼び出さないで下さい。これらのメソッドはオブジェクトのプロパティによって隠されている可能性があるかもしれません - `{ hasOwnProperty：false }`のようなケースを考えてください - あるいは、オブジェクトはnullオブジェクト( `Object.create(null)` )になっているかもしれません。
* オブジェクトをシャローコピーする場合は`Object.assign`よりもオブジェクトスプレッド構文を使用すること。特定のプロパティを省略した新しいオブジェクトを取得するには、オブジェクトのレスト演算子を使用すること。
以下に例を記します。
```js
// very bad
const original = { a: 1, b: 2 };
const copy = Object.assign(original, { c: 3 }); // this mutates `original` ಠ_ಠ
delete copy.a; // so does this

// bad
const original = { a: 1, b: 2 };
const copy = Object.assign({}, original, { c: 3 }); // copy => { a: 1, b: 2, c: 3 }

// good
const original = { a: 1, b: 2 };
const copy = { ...original, c: 3 }; // copy => { a: 1, b: 2, c: 3 }

const { a, ...noA } = copy; // noA => { b: 2, c: 3 }
```

## 配列

* 配列を作成する際は、オブジェクトの作成と同じようにリテラル構文を使用して下さい。
* 直接配列に項目を代入せず、Array#pushを使用して下さい。
* 配列をコピーする場合は、`const itemsCopy = [...items];`という風に配列の拡張演算子`...`を使用して下さい。
* 繰り返し可能なオブジェクトを配列に変換する場合は、
```js
const foo = document.querySelectorAll('.foo');

// good
const nodes = Array.from(foo);

// best
const nodes = [...foo];
```
という風に`Array.from`の代わりにスプレッド構文`...`を使用して下さい。
* array-likeオブジェクトを配列に変換する場合は、
`const arr = Array.prototype.slice.call(arrLike);`とするのではなく、
`const arr = Array.from(arrLike);`という風に`Array.from`を使用すること。
* 繰り返し可能なオブジェクト(iterables)へのマッピングにはスプレッド構文`...`の代わりに`Array.from`を使用すること。理由は中間配列の作成を防ぐためです。
* 配列のコールバック関数の中ではreturn構文を使用すること。もし関数の中が副作用のない式を返す一行で構成されている場合はreturnを省略してもかまいません。
* 配列が複数行ある場合、配列の開始の括弧の後と、最後の括弧の前に改行を入れること。

## 分割代入

* 複数のプロパティからなるオブジェクトにアクセスする際は、オブジェクト構造化代入を使用すること。構造化代入を利用することで、それらのプロパティのための中間的な参照を減らすことができます。具体的には、
```js
function getFullName(user) {
  const firstName = user.firstName;
  const lastName = user.lastName;

  return `${firstName} ${lastName}`;
}
```
とするのではなく、
```js
function getFullName({ firstName, lastName }) {
  return `${firstName} ${lastName}`;
}
```
という風にして下さい。
* 配列の構造化代入を使用して下さい。
* 複数の値を返却する場合は、配列の構造化代入ではなく、オブジェクトの構造化代入を使用すること。こうすることで、後で新しいプロパティを追加したり、呼び出し元に影響することなく順序を変更することができます。

## 文字列

* 文字列にはシングルクオート `''` を使用して下さい。
* 100文字以上になるような文字列は、文字列連結を使用して複数行にまたがって記述しない。
作業するうえで負担になる上にコードの検索容易性を損ないます。
* プログラムで文字列を生成する場合は、文字列連結ではなく、Template stringsを使用すること。Template strings は文字列補完機能・複数行文字列機能を持つ簡潔な構文で、可読性が良いからです。
* 絶対に eval() を利用しない。これは、いままで数多くの脆弱性を作って来たからです。
* 文字列の中で文字を不必要にエスケープしない。バックスラッシュは可読性を損なうため、必要なときにだけ存在させるべきです。

## 関数

* 関数宣言ではなく名前付き関数式を使用すること。関数の定義は巻き上げられます。このことはそれがファイルの中で定義されている場所よりも前に参照されることを意味します。それは読みやすさや保守性を損ないます。
関数の定義が十分に大きいか複雑であることがわかった場合、モジュールに展開するようにして下さい。
名前が定義されている変数から推測されるかどうかにかかわらず、式に明示的に名前を付けることを忘れないでください(モダンブラウザやBabelなどのコンパイラを使用している場合によくあります)。これにより、エラーの呼び出しスタックに関して行われた前提がなくなります。
* 即時呼び出し関数式(IIFE)を括弧で囲むこと。即時関数式は単一の単位であり、その両方とその呼び出し括弧を括弧で囲んで明確に表します。モジュールがある場合は必要ありません。
* 関数ではないブロック(`if`, `while`, など)の中で関数を定義しない。代わりに変数に関数を割り当てること。ブラウザは実行を許可しますが、すべて違ったように解釈されます。
* パラメータに`arguments`を指定しないで下さい。関数スコープに渡される`arguments`オブジェクトの参照を上書きしてしまいます。
* `arguments`を利用しない。代わりにrest syntax`...`を使用すること。`...`を利用することで、いつくかのパラメータを利用したいことを明らかにすることができます。加えてrestパラメータは`arguments`の様なArray-likeなオブジェクトではなく正真正銘のArrayです。
* 関数のパラメータを突然変異させるのではなく、デフォルトパラメータを使用すること。
```js
// really bad
function handleThings(opts) {
  // No! We shouldn't mutate function arguments.
  // Double bad: if opts is falsy it'll be set to an object which may
  // be what you want but it can introduce subtle bugs.

  // だめ！関数のパラメータを突然変異させるべきではありません。
  // もし、optsがfalsyだった場合は、望んだようにオブジェクトが設定されます。
  // しかし、微妙なバグを引き起こすかもしれません。
  opts = opts || {};
  // ...
}

// still bad
function handleThings(opts) {
  if (opts === void 0) {
    opts = {};
  }
  // ...
}

// good
function handleThings(opts = {}) {
  // ...
}
```
* 副作用のあるデフォルトパラメータの利用を避ける。
* `function handleThings(name, opts = {})`という風に常にデフォルトパラメータは末尾に配置すること。
* 新しい関数を作成するためにFunctionコンストラクタを使用しない。この方法で文字列を評価させて新しい関数を作成することは、eval()と同様の脆弱性を引き起こします。
```js
// bad
var add = new Function('a', 'b', 'return a + b');

// still bad
var subtract = Function('a', 'b', 'return a - b');
```
* 関数構文の中にスペースを入れること。
```js
// bad
const f = function(){};
const g = function (){};
const h = function() {};

// good
const x = function () {};
const y = function a() {};
```
* パラメータを直接操作しないこと。パラメータに渡されたオブジェクトを操作することは、呼び出し元にて望まれない値の副作用を及ぼす可能性があります。
```js
// bad
function f1(obj) {
  obj.key = 1;
}

// good
function f2(obj) {
  const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1;
}
```
* パラメータを再割り当てしない。特に`arguments`オブジェクトにアクセスするとき、パラメータを再割り当てすると予期しない動作をする可能性があります。 特にV8では最適化の問題も発生する可能性があります。
```js
// bad
function f1(a) {
  a = 1;
  // ...
}

function f2(a) {
  if (!a) { a = 1; }
  // ...
}

// good
function f3(a) {
  const b = a || 1;
  // ...
}

function f4(a = 1) {
  // ...
}
```
* 可変引数の関数を呼び出す場合はスプレッド演算子`...`を使用すること。
* 複数行の関数構文や呼び出しではインデントして下さい。最後の項目に末尾のコンマを付けて、行の各項目を単独で指定すること。

## アロー関数

* 無名関数を使用する必要がある場合は、アロー関数表記を使用してください。アロー関数はそのコンテキストの`this`で実行するバージョンの関数を作成します。これは通常期待通りの動作をし、より簡潔な構文だからです。
複雑な関数でロジックを定義した関数の外側に移動したい場合は使用しないで下さい。
* 関数本体が副作用のない式を返す単一の文で構成されている場合は、中括弧を省略して暗黙の戻り値を使用すること。そうでなければ、中括弧を付けて`return`文を使うこと。複数の関数が連結されている場合に読み易くなります。
* 式の全長が複数行にまたがる場合は、可読性をより良くするため丸括弧()で囲うこと。関数の開始と終了部分が分かりやすく見るためです。
* 関数が単一の引数を取り、中括弧を使用しない場合は、括弧を省略すること。 それ以外の場合は、明確さと一貫性を保つために、引数を常に括弧で囲むこと。常に括弧を使用する場合は、eslintに“always”オプションを使用すること。
* アロー関数の構文(`=>`)と比較演算子(`<=`、`>=`)を混同しない。
* 暗黙的な戻り値でアロー関数本体の位置を強制すること。

## クラスとコンストラクター

* `prototype`を直接操作することを避け、常に`class`を使用すること。
* 継承には`extends`を使用すること。
* メソッドの戻り値で`this`を返すことでメソッドチェーンを助けること。
```js
// bad
Jedi.prototype.jump = function () {
  this.jumping = true;
  return true;
};

Jedi.prototype.setHeight = function (height) {
  this.height = height;
};

const luke = new Jedi();
luke.jump(); // => true
luke.setHeight(20); // => undefined

// good
class Jedi {
  jump() {
    this.jumping = true;
    return this;
  }

  setHeight(height) {
    this.height = height;
    return this;
  }
}

const luke = new Jedi();

luke.jump()
  .setHeight(20);
```
* 独自の`toString()`の作成は認めますが、正しく動作することと副作用がないことを確認すること。
* 一つも指定されていない場合、クラスにはデフォルトのコンストラクタがあります。空のコンストラクタ関数やただ親クラスに移譲するだけのものは不要です。
* クラスのメンバの重複を避ける。重複したクラスメンバの宣言は暗黙的に最後のものが適用されます。重複を持つことはほぼ確実にバグです。

## モジュール

* 非標準モジュールシステム上では常にモジュール（`import`/`export`）を使用すること。いつもあなたの好みのモジュールシステムにトランスパイルすることができます。
* ワイルドカードインポートは使用しない。
* import文から直接exportしない。インポートする1つの明確な方法とエクスポートする1つの明確な方法を持つことは物事を一貫性のあるものにします。
* パスからは一箇所のみでインポートすること。同じパスからインポートする複数の行があると、コードが保守しにくくなります。
* 可変のバインディングをエクスポートしない。突然変異は一般的には避けるべきですが、特に可変のバインディングをエクスポートすることは避けてください。この手法はいくつかの特別な場合に必要になるかもしれませんが、一般的には定数参照だけをエクスポートするべきです。
* 単一のエクスポートを持つモジュールでは、名前付きエクスポートよりもデフォルトエクスポートすること。1つだけをエクスポートするファイルを増やすことをお勧めします。これは、読みやすさと保守性の点で優れています。
* すべての`import`をimport文以外の上に置くこと。 `import`は巻き上げられているので、それらすべてを一番上にしておくことは驚くべき振る舞いが起こるのを防ぎます。
* 複数行のインポートは、複数行の配列リテラルおよびオブジェクトリテラルと同じようにインデントすること。中括弧は、末尾のコンマと同様に、スタイルガイド内の他のすべての中括弧ブロックと同じインデント規則に従います。
* モジュールのインポート文でWebpackローダーの構文を許可しない。インポートでWebpack構文を使用することは、コードをモジュールバンドラーに結び付けてしまいます。`webpack.config.js`の中でローダー構文を使うようにしてください。

## イテレータとジェネレータ

* イテレータを使わない。`for-in`や`for-of`のようなループの代わりにJavaScriptの高階関数(higher-order functions)を使用すること。これは私たちの不変(immutable)のルールを強制します。値を返す純粋な関数を扱うことは、副作用よりも簡単に推論できます。配列を反復処理するには `map()` / `every()` / `filter()` / `find()` / `findIndex()` / `reduce()` / `some()` / … を使用すること。そして`Object.keys()` / `Object.values()` / `Object.entries()` で配列を作成してオブジェクトを反復処理できるようにすること。
* 今のところgeneratorsは使用しない。ES5にうまくトランスパイルできないからです。
* ジェネレータを使用する必要がある場合、またわれわれのアドバイスを無視する場合は、それらの関数シグネチャが適切に配置されていることを確認すること。`function`と`*`は同じ概念的なキーワードの一部です - `*`は`function`の修飾子ではなく、`function*`は`function`とは異なるユニークな構成要素です。

## プロパティ

* プロパティにアクセスする場合はドット(`.`)を使用すること。
* 変数を使用してプロパティにアクセスする場合は角括弧(`[]`)を使用すること
* べき乗を計算するときは、べき乗演算子`**`を使用すること。

## 変数

* 変数を宣言する際は、常に`const`か`let`を使用すること。使用しない場合はグローバル変数として宣言されてしまいます。グローバルな名前空間を汚染しないようにしましょう。
* 1つの変数宣言に対して1つの`const`を利用すること。この方法の場合、簡単に新しい変数を追加することができます。また、二度と区切り文字の違いによる`;`を`,`に置き換える作業を心配することがありません。すべての宣言を一度にジャンプするのではなく、デバッガーを使用して各宣言をステップスルーすることもできます。
* まず`const`をグループ化し、その後`let`をグループ化すること。以前に割り当てられた変数に後で変数を割り当てる必要がある場合に役立ちます。
* 変数を割り当てる際は、必要かつ合理的な場所で行うこと。`let`と`const`はブロックスコープだからです。関数スコープではありません。
* 変数代入を連結しない。変数代入を連鎖させると、暗黙のグローバル変数が作成されます。
* インクリメント演算子(`++`)デクリメント演算子(`--`)を使わない。インクリメントおよびデクリメント演算子は自動セミコロン挿入の対象となり、アプリケーション内で値の増加または減少を伴う予期せぬエラーを引き起こす可能性があります。`num++`や`num++`の代わりに`num += 1`のような構文で値を変更する方が表現力豊かです。インクリメントおよびデクリメント演算子を許可しないことで、直前の意図しない値の増加または減少による、プログラムでの予期しない動作を引き起こす可能性を防ぐことができます。
* 代入で`=`の前後に改行を入れない。あなたの代入が`max-len`に違反している場合は、値を丸括弧()で囲むこと。
* 未使用の変数を記述しない。宣言されていてコードのどこにも使用されていない変数は、不完全なリファクタリングによる失敗である可能性が最も高いです。このような変数はコード内のスペースを占有し、他の開発者にとって混乱を招く可能性があります。

## 巻き上げ

* `var`宣言は、それらに最も近い包含関数スコープの一番上に引き上げられますが、それらの代入は引き継がれません。`const`と`let`の宣言はTemporal Dead Zones(TDZ)と呼ばれる新しい概念の恩恵を受けています。なぜtypeofが安全ではなくなったのかを知ることは重要です。
* 無名関数の場合、関数が割当てされる前の変数が巻き上げられます。
* 名前付き関数の場合も同様に変数が巻き上げられます。関数名や関数本体は巻き上げられません。
* 関数宣言は関数名と関数本体が巻き上げられます。

## 比較演算子と同等性

* `if`文のような条件式は`ToBoolean`メソッドによる強制型変換で評価され、常に以下のルールに従います。

+ オブジェクトはtrueと評価されます。
+ undefinedはfalseと評価されます。
+ nullはfalseと評価されます。
+ 真偽値はboolean型の値として評価されます。
+ 数値はtrueと評価されます。しかし、+0, -0, NaNの場合は falseです。
+ 文字列はtrueと評価されます。しかし、空文字`''`の場合はfalse です。

* 真偽値にはショートカットを使用しますが、文字列と数値には明示的な比較を使用すること。
* `case`と`default`節でブロックを作成するには中括弧(`{}`)を使うこと。(例えば `let`、`const`、`function`、`class`) レキシカル宣言は`switch`ブロック全体から参照することができますが、代入されたときにだけ初期化され、それは`case`に達したときにだけ起こります。複数の`case`節が同じものを定義しようとするとき、これは問題を引き起こします。
* 三項演算子は入れ子にするべきではなく、一般に単一行にします。
* 不要な三項演算子を避ける。
* 演算子を混在させる場合は、それらを括弧で囲むこと。唯一の例外は、標準の算術演算子（`+`、`-`、`*`、`/`）です。これにより読みやすさが向上し、開発者の意図が明確になります。

## ブロック

* 複数行のブロックには中括弧（`{}`）を使用すること。
* `if`と`else`を使った複数行のブロックの場合は、`else`ブロックの閉じ括弧と同じ行に`else`を置くこと。
* `if`ブロックが常にreturn文を実行するのであれば、それに続く`else`ブロックは不要です。`return`を含む`if`ブロックに続く `else if`ブロック内の`return`は複数の`if`ブロックに分けることができます。

## 制御ステートメント

* 制御文（`if`、`while`など）が長くなり過ぎたり、最大行長を超えたりした場合、それぞれの（グループ化された）条件は新しい行に入れること。そして論理演算子で行を始めること。行の先頭で演算子を要求すると、演算子は整列されたままになり、メソッド連結と同様のパターンに従います。これにより、複雑なロジックを視覚的に理解しやすくなるため、読みやすくなります。
* 後続処理を選択するための演算子を制御文の代わりに使用しない。

## コメント

* 複数行のコメントには`/ ** ... * /`を使用すること。
* 単一行コメントには`//`を使用すること。コメントを加えたいコードの上部に配置すること。また、コメントの前に空行を入ること。
* 読みやすくするために、すべてのコメントをスペースで始めること。
* 問題を指摘して再考を促す場合や、問題の解決策を提案する場合など、コメントの前に`FIXME`や`TODO`を付けることで他の開発者の素早い理解を助けることができます。これらは、何らかのアクションを伴うという意味で通常のコメントとは異なります。アクションとは`FIXME -- 解決策が必要`もしくは`TODO -- 実装が必要`です。
* 問題に対する注釈として`// FIXME:`を使用すること。
* 問題の解決策に対する注釈として`// TODO:`を使用すること。

## 空白

* 半角スペース2文字を使用すること。
* 重要な中括弧（`{}`）の前にはスペースを1つ入れること。
* 制御構文（`if`文や`while`文など）の丸括弧（`()`）の前にはスペースを1つ入れること。関数宣言や関数呼び出し時の引数リストの前にはスペースは入れない。
* 演算子の間はスペースを入れること。
* ファイルの最後は改行文字を1つ入れること。
* 長くメソッドを連結する場合はインデントを使用すること。行がメソッド呼び出しではなく、新しい文であることを強調するために先頭にドット(.)を配置すること。
* 文の前とブロックの後には改行を残すこと。
* ブロックに空行を挟み込まない。
* 丸括弧(`()`)の内側にスペースを追加しない。
* 角括弧(`[]`)の内側にスペースを追加しない。
* 中括弧(`{}`)の内側にスペースを追加すること。
* 100文字を超えるコード行（空白を含む）を避ける。長い文字列はこの規則から除外されており、分割しない。
* 開いている中括弧(`{`)と同じ行の次の中括弧(`}`)の間に一定のスペースを空けること。この規則は、同じ行の閉じ中括弧(`}`)と前の中括弧(`{`)との間に一貫性のあるスペースを適用します。
* コンマの前にスペースを入れず、コンマの後にスペースを入れること。
* 計算用プロパティの括弧の中のスペースを強制する。
* 関数とその呼び出しの間にスペースを入れない。
* オブジェクトリテラルプロパティのキーと値の間のスペースを入れること。
* 行末に末尾のスペースを入れない。
* 複数の空行を避け、ファイルの終わりには改行を1つだけ入れること。

## カンマ

* 先頭のカンマは禁止。末尾につけること。

## セミコロン

* 改行をする時は必ずつけて下さい。

## 型キャストと強制

* 文の先頭で型の強制を行うこと。文字列の場合は`const totalScore = String(this.reviewScore);`という風にです。
* 数値の場合は型変換には`Number`を使用すること。`parseInt`を使用する場合、常に型変換のための基数を引数に渡すこと。
* パフォーマンス上の理由からBitshiftを使用する必要がある場合は、その理由と対処方法を説明するコメントを残してください。
* ビットシフト操作を使用するときは注意してください。数値は64ビット値として表されますが、ビットシフト操作は常に32ビット整数を返します。ここから。ビットシフトは、32ビットを超える整数値に対して予期しない動作を引き起こす可能性があります。ディスカッション。符号付き32ビット整数の最大値は2,147,483,647です。

## 命名規則

* 1文字の名前は避ける。名前から意図が読み取れるようにすること。
* オブジェクト、関数、インスタンスにはキャメルケース（小文字から始まる）を使用すること。
* クラスやコンストラクタにはパスカルケース（大文字から始まる）を使用すること。
* 末尾または先頭のアンダースコアを避ける。 JavaScriptは、プロパティやメソッドについてのプライバシーの概念を持っていません。先頭のアンダースコアは「非公開」を意味する一般的な規則ですが、実際にはこれらのプロパティは完全に公開されているため公開APIの一部です。この規約により、開発者は変更が壊れているとは見なされない、またはテストが必要ではないと誤って考える可能性があります。あなたが何かを「非公開」にしたいのであれば、それは明らかに存在してはいけません。
* `this`の参照を保存するのを避ける。アロー関数かFunction#bindを利用すること。
* ファイルを1つのクラスとしてexportする場合、ファイル名はクラス名と完全に一致させること。
* Default exportが関数の場合、キャメルケース（小文字から始まる）を使用すること。ファイル名は関数名と同じにすること。
* シングルトン / function library / 単なるオブジェクトをexportする場合、パスカルケース（大文字から始まる）を使用すること。
* 略語およびinitialisms（複数の単語で構成される言葉の頭文字をとって一つの単語にしたもの）は、常にすべて大文字、またはすべて小文字にする必要があります。
* （1）エクスポートされ、（2）`const`（再割り当てできない）であり、そして（3）プログラマがそれを（そしてネストされたプロパティも）変更しないと信頼できる場合に限り、定数を大文字にすることができます。

## アクセサ

* プロパティのためのアクセサ関数は必須ではありません。
* 予期しない副作用を引き起こし、テスト、保守、および理由の説明が難しいため、JavaScriptのゲッター/セッターは使用しないこと。代わりに、アクセサ関数を作るのであれば、`getVal()`とか`setVal('hello')`とすること。
* プロパティ/メソッドが`boolean`の場合は、`isVal()`または`hasVal()`を使用すること。
* 一貫していれば、`get()`や`set()`という関数を作成することを認める。

## イベント

* データペイロードをイベント（DOMイベントまたはBackboneイベントのようなもっと独自のものかどうかにかかわらず）に添付するときは、生の値の代わりにオブジェクトリテラル（「ハッシュ」とも呼ばれる）を渡すこと。これにより、後の開発者は、イベントのすべてのハンドラを見つけて更新することなく、イベントペイロードにさらにデータを追加できます。たとえば、下の例より
```js
// bad
$(this).trigger('listingUpdated', listing.id);

...

$(this).on('listingUpdated', function(e, listingId) {
  // do something with listingId
});
```
prefer: こちらの方が好まれます:
```js
// good
$(this).trigger('listingUpdated', { listingId: listing.id });

...

$(this).on('listingUpdated', function(e, data) {
  // do something with data.listingId
});
```

## jQuery

* jQueryオブジェクトの変数は、先頭に`$`を付与すること。
* jQueryの検索結果をキャッシュすること。
* DOMの検索には、`$('.sidebar ul')`や`$('.sidebar > ul')`のカスケードを使用すること。
* jQueryオブジェクトの検索には、スコープ付きの`find`を使用すること。

## 標準ライブラリ

標準ライブラリには機能的には壊れているがレガシーな理由で残っているユーティリティが含まれています。
* グローバルな`isNaN`の代わりに`Number.isNaN`を使用すること。
* グローバルな`isFinite`の代わりに`Number.isFinite`を使用する。

## テスト

* どのテストフレームワークを使用する場合でも、テストを書く必要があります！
* 多くの小さな単純な関数を書くようにし、突然変異が起こる場所を最小限に抑えるようにしてください。
* スタブやモックについては注意してください - それ自体があなたのテストをより脆弱にする可能性があります。
* Airbnbでは主に`mocha`と`jest`を使います。`tape`は小さな別々のモジュールに時々使われます。
* 100％テストカバレッジは、それを達成することが必ずしも現実的ではない場合でも、努力するための良い目標です。
* あなたがバグを修正する時はいつでも回帰テストを書くこと。回帰テストなしで修正されたバグは、ほぼ確実に将来再び壊れるでしょう。
